<link rel="stylesheet" href="/style/css/backlog.css">

<main class="layout-lock">
  <div id="backlog-bg"></div>
  <button id="draw-btn" onclick="drawBacklog()">Attack Backlog</button>
  <div id="game-cards" class="card-grid"></div>
</main>

<script>
  // global state for this page
  let currentCardEls = [];
  let canSelectCard = false;
  let backlogTimers = [];
  let backlogCancelled = false; // <--- master kill switch

  function addTimer(id) {
    backlogTimers.push(id);
  }

  async function drawBacklog() {
    // reset everything for a fresh run
    backlogTimers.forEach(clearTimeout);
    backlogTimers = [];
    backlogCancelled = false; // <--- we're doing a new draw
    canSelectCard = false;

    const unlockSound = new Audio('/style/sounds/unlock.mp3');
    try { unlockSound.play(); } catch (e) {}

    const button = document.getElementById('draw-btn');
    const container = document.getElementById('game-cards');
    container.innerHTML = '';
    currentCardEls = [];

    if (!button.classList.contains('rise-up')) {
      button.classList.add('rise-up');
    }

    try {
      const res = await fetch('/api/backlog/random');
      const games = await res.json(); // now: [{id, name, source}, ...]

      const cards = [];

      games.forEach((game) => {
        const card = document.createElement('div');
        card.className = 'flip-card';

        const inner = document.createElement('div');
        inner.className = 'flip-card-inner';

        const front = document.createElement('div');
        front.className = 'flip-card-front';
        front.textContent = "?";

        const back = document.createElement('div');
        back.className = 'flip-card-back';
        back.textContent = game.name;               // use game.name now

        inner.appendChild(front);
        inner.appendChild(back);
        card.appendChild(inner);
        container.appendChild(card);

        // stash data for later
        card.dataset.gameName = game.name;
        card.dataset.source = game.source || 'Unknown';

        cards.push(card);
      });

      currentCardEls = cards;

      // 1) staged appear
      const appearTimer = setTimeout(() => {
        if (backlogCancelled) return;
        cards.forEach((card, index) => {
          const t = setTimeout(() => {
            if (backlogCancelled) return;
            card.classList.add('dissolve-in');
          }, index * 150);
          addTimer(t);
        });

        // 2) then staged flip
        const flipStart = cards.length * 150 + 500;
        const flipTimer = setTimeout(() => {
          if (backlogCancelled) return;
          cards.forEach((card, index) => {
            const tt = setTimeout(() => {
              if (backlogCancelled) return;
              const sound = new Audio('/style/sounds/flip.mp3');
              try { sound.play(); } catch (e) {}
              card.classList.add('flipped');
            }, index * 500);
            addTimer(tt);
          });

          // 3) finally, allow selection
          const allowTimer = setTimeout(() => {
            if (backlogCancelled) return;
            canSelectCard = true;
            cards.forEach(cardEl => {
              cardEl.addEventListener('click', () => handleCardSelect(cardEl));
            });
          }, (cards.length * 500) + 650);
          addTimer(allowTimer);

        }, flipStart);
        addTimer(flipTimer);

      }, 1000);
      addTimer(appearTimer);

    } catch (err) {
      console.error("âŒ Error in drawBacklog():", err);
    }
  }

  function handleCardSelect(selectedCard) {
    if (!canSelectCard) return;
    canSelectCard = false;
    backlogCancelled = true; // stop any leftover reveal/flip logic

    // clear previously scheduled timeouts
    backlogTimers.forEach(clearTimeout);
    backlogTimers = [];

    const container = document.getElementById('game-cards');
    const cards = currentCardEls || [];

    // 1) get container box ONCE
    const containerRect = container.getBoundingClientRect();

    // 2) FIRST PASS: capture positions for ALL cards before we change layout
    const frozen = cards.map((card) => {
      const r = card.getBoundingClientRect();
      return {
        el: card,
        left: r.left - containerRect.left,
        top: r.top - containerRect.top,
        width: r.width,
        height: r.height
      };
    });

    // 3) SECOND PASS: apply absolute positioning using frozen values
    frozen.forEach((item) => {
      const card = item.el;
      card.style.position = 'absolute';
      card.style.left = item.left + 'px';
      card.style.top = item.top + 'px';
      card.style.width = item.width + 'px';
      card.style.height = item.height + 'px';
      card.style.zIndex = card === selectedCard ? '10' : '5';
    });

    // 4) fade out *other* cards slowly
    let delay = 0;
    const fadeDuration = 1500;

    cards.forEach((card) => {
      if (card === selectedCard) return;

      const t = setTimeout(() => {
        card.classList.add('card-fade-away');

        const rm = setTimeout(() => {
          if (card.parentNode) card.parentNode.removeChild(card);
        }, fadeDuration + 80);
        addTimer(rm);

      }, delay);
      addTimer(t);

      delay += 350; // nice cascade
    });

    // 5) after fades, move selected to center
    const moveDelay = delay + 200;
    const moveTimer = setTimeout(() => {
      const targetLeft = (containerRect.width / 2) - (selectedCard.offsetWidth / 2);
      const targetTop = (containerRect.height / 2) - (selectedCard.offsetHeight / 2);

      selectedCard.style.transition = 'left .45s ease, top .45s ease';
      selectedCard.style.left = targetLeft + 'px';
      selectedCard.style.top = targetTop + 'px';
      selectedCard.style.zIndex = '20';
    }, moveDelay);
    addTimer(moveTimer);

    // 6) shake + ATTACKED + show SOURCE
    const celebrateTimer = setTimeout(() => {
      selectedCard.classList.add('card-shake');

      try {
        const boom = new Audio('/style/sounds/unlock.mp3');
        boom.play();
      } catch (e) {}

      const badge = document.createElement('div');
      badge.className = 'attack-badge';
      badge.textContent = 'ATTACKED';
      selectedCard.appendChild(badge);

      const flare = document.createElement('div');
      flare.className = 'attack-badge-flare';
      selectedCard.appendChild(flare);

      const pulse = document.createElement('div');
      pulse.className = 'attack-pulse';
      selectedCard.appendChild(pulse);

      selectedCard.classList.add('attack-glow');

      // NEW: show source under the chosen card
      const src = selectedCard.dataset.source || 'Unknown';
      if (!selectedCard.querySelector('.attack-source')) {
        const srcP = document.createElement('p');
        srcP.className = 'attack-source';
        srcP.textContent = 'Source: ' + src;
        selectedCard.appendChild(srcP);
      }

      setTimeout(() => {
        if (pulse.parentNode) {
          pulse.parentNode.removeChild(pulse);
        }
        selectedCard.classList.remove('attack-glow');
      }, 1600);

    }, moveDelay + 550);
    addTimer(celebrateTimer);
  }

  async function populateBacklogBackground() {
    const res = await fetch('/api/backlog/sample');
    const games = await res.json();
    const container = document.getElementById('backlog-bg');

    container.innerHTML = '';

    games.forEach(game => {
      const div = document.createElement('div');
      div.className = 'bg-title';
      div.textContent = game;
      container.appendChild(div);
    });
  }

  document.addEventListener('DOMContentLoaded', populateBacklogBackground);
</script>
